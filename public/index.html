<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-K07KHPP18P"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-K07KHPP18P');
  </script>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Website Roaster - AI-Powered Corporate Buzzword Detector</title>
  <meta name="description" content="Let AI roast your website's corporate speak. Brutally honest analysis of buzzwords, vague claims, and marketing fluff.">
  
  <!-- Open Graph / Facebook / LinkedIn -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://www.wroast.co/">
  <meta property="og:title" content="üî• Website Roaster - How Cringe Is Your Website?">
  <meta property="og:description" content="AI-powered roasts of corporate buzzword salad. Find out if your website sounds like every other 'innovative, industry-leading solution' out there.">
  <meta property="og:image" content="https://www.wroast.co/og-preview.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  
  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:url" content="https://www.wroast.co/">
  <meta name="twitter:title" content="üî• Website Roaster - How Cringe Is Your Website?">
  <meta name="twitter:description" content="AI-powered roasts of corporate buzzword salad. Find out if your website sounds like every other 'innovative, industry-leading solution' out there.">
  <meta name="twitter:image" content="https://www.wroast.co/og-preview.png">
  
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üî•</text></svg>">
  <link rel="canonical" href="https://www.wroast.co/">
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%);
      min-height: 100vh;
    }
    @keyframes shimmer {
      0% { background-position: 0% center; }
      100% { background-position: 200% center; }
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const LOADING_MESSAGES = [
      "Scanning for corporate cringe...",
      "Counting the buzzwords... there are many...",
      "Detecting thought leadership in the wild...",
      "Analyzing synergy levels... off the charts...",
      "Measuring disruption per paragraph...",
      "Calculating ROI of their word choices...",
      "Searching for actual meaning... still searching...",
      "Evaluating their 'innovative solutions'...",
      "Cross-referencing with LinkedIn dictionary...",
      "Checking if they really are 'industry-leading'...",
    ];

    const ROASTING_MESSAGES = [
      "Crafting the perfect roast...",
      "Finding the spiciest takes...",
      "Sharpening our wit...",
      "Consulting the council of sarcasm...",
      "Brewing a fresh batch of burns...",
      "Polishing the zingers...",
      "Loading maximum snark...",
      "Preparing constructive destruction...",
    ];

    const TTS_LOADING_MESSAGES = [
      "Warming up the vocal cords...",
      "Channeling disappointed copywriter energy...",
      "Loading sarcasm modules...",
      "Preparing to roast audibly...",
      "Converting cringe to audio...",
      "Generating dramatic pauses...",
    ];

    function stripAudioTags(text) {
      if (!text) return '';
      return text.replace(/\[(?:sighs?|chuckles?|laughs?|sarcastically|dramatically|pause|sassy|sarcastic|comedic)[^\]]*\]/gi, '').replace(/\s+/g, ' ').trim();
    }

    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function ProgressIndicator({ stage, loadingMessages, roastingMessages, ttsLoadingMessage }) {
      const stages = [
        { key: 'analyzing', label: 'Analyzing website', icon: 'üîç' },
        { key: 'roasting', label: 'Generating roast', icon: 'üî•' },
        { key: 'audio', label: 'Creating audio', icon: 'üéôÔ∏è' }
      ];
      let currentIndex = stages.findIndex(s => s.key === stage);
      if (currentIndex === -1) currentIndex = 0;
      const currentMessages = stage === 'roasting' ? roastingMessages : loadingMessages;
      
      return (
        <div style={{ textAlign: 'center', padding: '40px 0' }}>
          <div style={{ display: 'flex', justifyContent: 'center', gap: '8px', marginBottom: '32px', flexWrap: 'wrap' }}>
            {stages.map((s, index) => {
              const isComplete = index < currentIndex;
              const isCurrent = index === currentIndex;
              return (
                <div key={s.key} style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                  <div style={{
                    display: 'flex', alignItems: 'center', gap: '8px', padding: '8px 16px',
                    background: isComplete ? '#22c55e22' : isCurrent ? '#8b5cf622' : '#1a1a2e',
                    border: '2px solid ' + (isComplete ? '#22c55e' : isCurrent ? '#8b5cf6' : '#333'),
                    borderRadius: '24px'
                  }}>
                    <span style={{ fontSize: '16px' }}>{isComplete ? '‚úì' : s.icon}</span>
                    <span style={{ color: isComplete ? '#22c55e' : isCurrent ? '#fff' : '#666', fontSize: '14px', fontWeight: isCurrent ? 'bold' : 'normal' }}>{s.label}</span>
                  </div>
                  {index < stages.length - 1 && <div style={{ width: '24px', height: '2px', background: isComplete ? '#22c55e' : '#333' }} />}
                </div>
              );
            })}
          </div>
          <div style={{ fontSize: '48px', marginBottom: '16px', animation: 'spin 2s linear infinite' }}>{stages[currentIndex].icon}</div>
          {stage === 'audio' ? (
            <p style={{ color: '#fff', fontSize: '16px', margin: '8px 0' }}>{ttsLoadingMessage}</p>
          ) : (
            <div style={{ maxHeight: '150px', overflow: 'hidden', marginBottom: '16px' }}>
              {currentMessages.map((msg, index) => (
                <p key={index} style={{ color: index === currentMessages.length - 1 ? '#fff' : '#666', fontSize: index === currentMessages.length - 1 ? '16px' : '13px', margin: '8px 0', opacity: index === currentMessages.length - 1 ? 1 : 0.6 }}>
                  {index === currentMessages.length - 1 ? msg : '‚úì ' + msg}
                </p>
              ))}
            </div>
          )}
          <p style={{ color: '#666', fontSize: '14px', marginTop: '16px' }}>{stage === 'audio' ? "Almost there!" : "This might take a moment."}</p>
        </div>
      );
    }

    const BUZZWORDS = ['synergy','leverage','disrupt','innovative','scalable','ai-powered','revolutionary','game-changing','cutting-edge','best-in-class','world-class','next-gen','robust','holistic','paradigm','ecosystem','seamless','frictionless','agile','pivot','digital transformation','deep dive','value-add','stakeholder','empower','data-driven','actionable insights','thought leader','industry-leading'];
    const VAGUE_CLAIMS = ['industry leader','market leader','trusted by','award-winning','best in class','unparalleled','innovative solutions','proven track record','dedicated team','passionate about','customer satisfaction','easy to use','years of experience'];
    const CTAS = ['sign up','get started','learn more','book a demo','contact us','subscribe','buy now','limited time','click here','transform your','unlock','discover'];

    function analyzeText(text) {
      if (!text) return { buzzwords: { total: 0, matches: {} }, vagueClaims: { total: 0, matches: {} }, ctas: { total: 0, matches: {} }, exclamationCount: 0, wordCount: 0, avgWordLength: 0, avgSentenceLength: 0, weYouRatio: "0" };
      const countMatches = (list) => {
        const matches = {};
        list.forEach(item => {
          const regex = new RegExp('\\b' + item.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '\\b', 'gi');
          const found = (text.match(regex) || []).length;
          if (found > 0) matches[item] = found;
        });
        return { total: Object.values(matches).reduce((a, b) => a + b, 0), matches };
      };
      const words = text.split(/\s+/).filter(w => w.length > 0);
      const wordCount = words.length;
      const totalChars = words.reduce((sum, w) => sum + w.replace(/[^a-zA-Z]/g, '').length, 0);
      const avgWordLength = wordCount > 0 ? (totalChars / wordCount).toFixed(1) : 0;
      const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
      const avgSentenceLength = sentences.length > 0 ? Math.round(wordCount / sentences.length) : 0;
      const weCount = (text.match(/\b(we|our|us)\b/gi) || []).length;
      const youCount = (text.match(/\b(you|your|yours)\b/gi) || []).length;
      const weYouRatio = youCount > 0 ? (weCount / youCount).toFixed(1) : weCount > 0 ? "‚àû" : "0";
      return { buzzwords: countMatches(BUZZWORDS), vagueClaims: countMatches(VAGUE_CLAIMS), ctas: countMatches(CTAS), exclamationCount: (text.match(/!/g) || []).length, wordCount, avgWordLength, avgSentenceLength, weYouRatio };
    }

    function ReportCard({ title, score, thresholds, details, icon }) {
      let grade, gradeColor;
      if (score <= thresholds.a) { grade = 'A'; gradeColor = '#22c55e'; }
      else if (score <= thresholds.b) { grade = 'B'; gradeColor = '#84cc16'; }
      else if (score <= thresholds.c) { grade = 'C'; gradeColor = '#eab308'; }
      else if (score <= thresholds.d) { grade = 'D'; gradeColor = '#f97316'; }
      else { grade = 'F'; gradeColor = '#ef4444'; }
      return (
        <div style={{ background: '#1a1a2e', borderRadius: '16px', padding: '20px', border: '1px solid #2a2a4e' }}>
          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '12px' }}>
            <span style={{ fontSize: '14px', color: '#888' }}>{icon} {title}</span>
            <span style={{ fontSize: '24px', fontWeight: 'bold', color: gradeColor, textShadow: '0 0 20px ' + gradeColor + '44' }}>{grade}</span>
          </div>
          <div style={{ fontSize: '36px', fontWeight: 'bold', marginBottom: '8px' }}>{score}</div>
          {details && details.length > 0 && (
            <div style={{ fontSize: '12px', color: '#666', maxHeight: '60px', overflow: 'auto' }}>
              {details.slice(0, 5).map(([word, count]) => <span key={word} style={{ marginRight: '8px' }}>"{word}" √ó{count}</span>)}
              {details.length > 5 && <span>+{details.length - 5} more</span>}
            </div>
          )}
        </div>
      );
    }

    function WebsiteRoaster() {
      const [url, setUrl] = useState('');
      const [loading, setLoading] = useState(false);
      const [roast, setRoast] = useState('');
      const [results, setResults] = useState(null);
      const [error, setError] = useState('');
      const [loadingMessages, setLoadingMessages] = useState([]);
      const [roastingMessages, setRoastingMessages] = useState([]);
      const [currentStage, setCurrentStage] = useState('analyzing');
      const [audioUrl, setAudioUrl] = useState(null);
      const [ttsError, setTtsError] = useState('');
      const [isAudioPlaying, setIsAudioPlaying] = useState(false);
      const [ttsLoadingMessage, setTtsLoadingMessage] = useState('');
      const audioRef = useRef(null);
      const [showTranscript, setShowTranscript] = useState(false);
      const [audioCurrentTime, setAudioCurrentTime] = useState(0);
      const [audioDuration, setAudioDuration] = useState(0);
      const [shareUrl, setShareUrl] = useState('');
      const [isSharing, setIsSharing] = useState(false);
      const [copySuccess, setCopySuccess] = useState(false);

      useEffect(() => {
        const pathMatch = window.location.pathname.match(/^\/r\/(.+)$/);
        if (pathMatch) loadSharedRoast(pathMatch[1]);
        else {
          const cached = localStorage.getItem('lastRoast');
          if (cached) {
            try {
              const data = JSON.parse(cached);
              if (data.url && data.roast && data.results) {
                setUrl(data.url); setRoast(data.roast); setResults(data.results);
                if (data.audio) {
                  const binary = atob(data.audio);
                  const bytes = new Uint8Array(binary.length);
                  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
                  setAudioUrl(URL.createObjectURL(new Blob([bytes], { type: 'audio/mpeg' })));
                }
                if (data.shareUrl) setShareUrl(data.shareUrl);
              }
            } catch (e) {}
          }
        }
      }, []);

      async function loadSharedRoast(shareId) {
        setLoading(true); setCurrentStage('analyzing');
        try {
          const response = await fetch('/api/share/' + shareId);
          if (!response.ok) throw new Error('Roast not found');
          const data = await response.json();
          setUrl(data.url); setRoast(data.roast); setResults(data.results); setShareUrl(window.location.href);
          if (data.audio) {
            const binary = atob(data.audio);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
            setAudioUrl(URL.createObjectURL(new Blob([bytes], { type: 'audio/mpeg' })));
          }
        } catch (err) { setError('This roast has expired or does not exist'); }
        finally { setLoading(false); }
      }

      useEffect(() => {
        if (audioRef.current) {
          const audio = audioRef.current;
          const updateTime = () => setAudioCurrentTime(audio.currentTime);
          const updateDuration = () => setAudioDuration(audio.duration);
          const handleEnded = () => setIsAudioPlaying(false);
          audio.addEventListener('timeupdate', updateTime);
          audio.addEventListener('loadedmetadata', updateDuration);
          audio.addEventListener('ended', handleEnded);
          return () => { audio.removeEventListener('timeupdate', updateTime); audio.removeEventListener('loadedmetadata', updateDuration); audio.removeEventListener('ended', handleEnded); };
        }
      }, [audioUrl]);

      const formatTime = (seconds) => { if (!seconds || isNaN(seconds)) return '0:00'; const mins = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return mins + ':' + secs.toString().padStart(2, '0'); };
      const seekTo = (e) => { if (audioRef.current && audioDuration) { const rect = e.currentTarget.getBoundingClientRect(); audioRef.current.currentTime = ((e.clientX - rect.left) / rect.width) * audioDuration; } };
      const skipTime = (seconds) => { if (audioRef.current) audioRef.current.currentTime = Math.max(0, Math.min(audioDuration, audioRef.current.currentTime + seconds)); };
      const toggleAudio = () => { if (audioRef.current) { if (isAudioPlaying) audioRef.current.pause(); else audioRef.current.play(); setIsAudioPlaying(!isAudioPlaying); } };

      async function copyToClipboard(text) {
        try { await navigator.clipboard.writeText(text); setCopySuccess(true); setTimeout(() => setCopySuccess(false), 2000); return true; }
        catch (err) {
          try {
            const textArea = document.createElement('textarea'); textArea.value = text; textArea.style.position = 'fixed'; textArea.style.left = '-999999px';
            document.body.appendChild(textArea); textArea.focus(); textArea.select();
            const success = document.execCommand('copy'); document.body.removeChild(textArea);
            if (success) { setCopySuccess(true); setTimeout(() => setCopySuccess(false), 2000); return true; }
          } catch (e) {}
          return false;
        }
      }

      async function handleSubmit(e) {
        e.preventDefault();
        if (!url) return;
        setLoading(true); setError(''); setRoast(''); setResults(null); setLoadingMessages([]); setRoastingMessages([]); setAudioUrl(null); setTtsError(''); setCurrentStage('analyzing'); setShareUrl(''); setShowTranscript(false);
        localStorage.removeItem('lastRoast');
        if (window.location.pathname.startsWith('/r/')) window.history.pushState({}, '', '/');

        const messageInterval = setInterval(() => {
          setLoadingMessages(prev => {
            const available = LOADING_MESSAGES.filter(m => !prev.includes(m));
            if (available.length === 0) return prev;
            return [...prev, available[Math.floor(Math.random() * available.length)]];
          });
        }, 1500);

        try {
          let urlToAnalyze = url.trim();
          if (!urlToAnalyze.startsWith('http://') && !urlToAnalyze.startsWith('https://')) urlToAnalyze = 'https://' + urlToAnalyze;

          const [response] = await Promise.all([
            fetch('/api/analyze', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ url: urlToAnalyze }) }),
            delay(6000)
          ]);
          clearInterval(messageInterval);
          setCurrentStage('roasting');

          const roastingInterval = setInterval(() => {
            setRoastingMessages(prev => {
              const available = ROASTING_MESSAGES.filter(m => !prev.includes(m));
              if (available.length === 0) return prev;
              return [...prev, available[Math.floor(Math.random() * available.length)]];
            });
          }, 1500);

          const responseText = await response.text();
          if (!response.ok) { clearInterval(roastingInterval); throw new Error(responseText || 'API Error'); }
          const data = JSON.parse(responseText);
          let parsedResponse = null;
          if (data.content && Array.isArray(data.content)) {
            for (const block of data.content) {
              if (block.type === 'text' && block.text) {
                try { const jsonMatch = block.text.match(/\{[\s\S]*"roast"[\s\S]*\}/); if (jsonMatch) { parsedResponse = JSON.parse(jsonMatch[0]); break; } } catch (e) {}
              }
            }
          }
          if (!parsedResponse) { clearInterval(roastingInterval); throw new Error('Could not parse response'); }

          await delay(6000);
          clearInterval(roastingInterval);

          const analyzedResults = analyzeText(parsedResponse.pageText);
          setResults(analyzedResults); setRoast(parsedResponse.roast);
          setCurrentStage('audio');

          let ttsMessageIndex = 0;
          setTtsLoadingMessage(TTS_LOADING_MESSAGES[0]);
          const ttsInterval = setInterval(() => { ttsMessageIndex = (ttsMessageIndex + 1) % TTS_LOADING_MESSAGES.length; setTtsLoadingMessage(TTS_LOADING_MESSAGES[ttsMessageIndex]); }, 2500);

          try {
            const ttsResponse = await fetch('/api/tts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text: parsedResponse.roast }) });
            clearInterval(ttsInterval);
            if (ttsResponse.ok) {
              const audioBlob = await ttsResponse.blob();
              setAudioUrl(URL.createObjectURL(audioBlob));
              const reader = new FileReader();
              reader.onloadend = () => { localStorage.setItem('lastRoast', JSON.stringify({ url: urlToAnalyze, roast: parsedResponse.roast, results: analyzedResults, audio: reader.result.split(',')[1], timestamp: Date.now() })); };
              reader.readAsDataURL(audioBlob);
            } else throw new Error('TTS failed');
          } catch (ttsErr) { clearInterval(ttsInterval); setTtsError('Audio generation failed'); localStorage.setItem('lastRoast', JSON.stringify({ url: urlToAnalyze, roast: parsedResponse.roast, results: analyzedResults, timestamp: Date.now() })); }
        } catch (err) { setError(err.message || 'Something went wrong'); }
        finally { setLoading(false); }
      }

      async function handleShare() {
        if (!roast || !results || isSharing) return;
        if (shareUrl) { await copyToClipboard(shareUrl); return; }
        setIsSharing(true);
        try {
          let audioBase64 = null;
          const cached = localStorage.getItem('lastRoast');
          if (cached) audioBase64 = JSON.parse(cached).audio;
          const response = await fetch('/api/share', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ url, roast, results, audio: audioBase64 }) });
          if (!response.ok) throw new Error('Failed to create share link');
          const data = await response.json();
          setShareUrl(data.shareUrl);
          if (cached) { const cachedData = JSON.parse(cached); cachedData.shareUrl = data.shareUrl; localStorage.setItem('lastRoast', JSON.stringify(cachedData)); }
          const copied = await copyToClipboard(data.shareUrl);
          if (!copied) { setCopySuccess(true); setTimeout(() => setCopySuccess(false), 2000); }
        } catch (err) { setTtsError('Failed to create share link: ' + err.message); }
        finally { setIsSharing(false); }
      }

      return (
        <div style={{ minHeight: '100vh', color: '#fff', fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif', padding: '20px' }}>
          <div style={{ maxWidth: '800px', margin: '0 auto' }}>
            <div style={{ textAlign: 'center', marginBottom: '40px', marginTop: '40px' }}>
              <h1 style={{ fontSize: 'clamp(2rem, 8vw, 3.5rem)', fontWeight: 'bold', marginBottom: '16px', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '16px' }}>
                <span style={{ fontSize: 'clamp(2rem, 8vw, 3rem)' }}>üî•</span>
                <span style={{ background: 'linear-gradient(135deg, #ff6b6b, #feca57, #ff6b6b)', backgroundSize: '200% auto', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent', animation: 'shimmer 3s linear infinite' }}>Website Roaster</span>
                <span style={{ fontSize: 'clamp(2rem, 8vw, 3rem)' }}>üî•</span>
              </h1>
              <p style={{ color: '#888', fontSize: '1.1rem' }}>Let AI roast your corporate buzzword bingo</p>
            </div>

            <form onSubmit={handleSubmit} style={{ marginBottom: '32px' }}>
              <div style={{ display: 'flex', gap: '12px', flexWrap: 'wrap' }}>
                <input type="text" value={url} onChange={(e) => setUrl(e.target.value)} placeholder="Enter website URL (e.g., example.com)" style={{ flex: 1, minWidth: '200px', padding: '16px 20px', fontSize: '16px', border: '2px solid #333', borderRadius: '12px', background: '#1a1a2e', color: '#fff', outline: 'none' }} />
                <button type="submit" disabled={loading || !url} style={{ padding: '16px 32px', fontSize: '16px', fontWeight: 'bold', border: 'none', borderRadius: '12px', background: loading ? '#333' : 'linear-gradient(135deg, #ff6b6b, #ee5a5a)', color: '#fff', cursor: loading ? 'not-allowed' : 'pointer' }}>{loading ? 'üî• Roasting...' : 'üî• Roast It!'}</button>
              </div>
            </form>

            {loading && <ProgressIndicator stage={currentStage} loadingMessages={loadingMessages} roastingMessages={roastingMessages} ttsLoadingMessage={ttsLoadingMessage} />}
            {error && <div style={{ padding: '20px', background: '#2a1a1a', border: '1px solid #ff6b6b44', borderRadius: '12px', color: '#ff6b6b', marginBottom: '24px' }}><strong>Oops!</strong> {error}</div>}

            {results && !loading && (
              <div>
                <div style={{ background: 'linear-gradient(135deg, #1a1a2e, #2a2a4e)', borderRadius: '16px', padding: '24px', marginBottom: '24px', border: '1px solid #333' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px', flexWrap: 'wrap', gap: '12px' }}>
                    <h2 style={{ fontSize: '24px', display: 'flex', alignItems: 'center', gap: '8px' }}>üé§ The Roast</h2>
                    <button onClick={handleShare} disabled={isSharing} style={{ padding: '8px 16px', fontSize: '14px', background: copySuccess ? '#22c55e' : shareUrl ? '#8b5cf6' : '#2a2a4e', border: '1px solid ' + (copySuccess ? '#22c55e' : shareUrl ? '#8b5cf6' : '#444'), borderRadius: '8px', color: '#fff', cursor: isSharing ? 'not-allowed' : 'pointer' }}>
                      {isSharing ? '‚è≥ Creating...' : copySuccess ? '‚úì Copied!' : shareUrl ? 'üîó Copy Link' : 'üîó Share'}
                    </button>
                  </div>

                  {audioUrl && (
                    <div style={{ background: '#0f0f1a', borderRadius: '12px', padding: '16px', marginBottom: '16px' }}>
                      <audio ref={audioRef} src={audioUrl} />
                      <div onClick={seekTo} style={{ height: '6px', background: '#333', borderRadius: '3px', marginBottom: '12px', cursor: 'pointer' }}>
                        <div style={{ height: '100%', background: 'linear-gradient(90deg, #8b5cf6, #a78bfa)', borderRadius: '3px', width: (audioDuration ? (audioCurrentTime / audioDuration) * 100 : 0) + '%' }} />
                      </div>
                      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '16px' }}>
                        <span style={{ fontSize: '12px', color: '#666', minWidth: '40px' }}>{formatTime(audioCurrentTime)}</span>
                        <button onClick={() => skipTime(-15)} style={{ padding: '8px 12px', fontSize: '12px', background: '#2a2a4e', border: '1px solid #444', borderRadius: '8px', color: '#fff', cursor: 'pointer' }}>-15s</button>
                        <button onClick={toggleAudio} style={{ padding: '12px', fontSize: '20px', background: 'linear-gradient(135deg, #8b5cf6, #7c3aed)', border: 'none', borderRadius: '50%', color: '#fff', cursor: 'pointer', width: '50px', height: '50px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>{isAudioPlaying ? '‚è∏' : '‚ñ∂'}</button>
                        <button onClick={() => skipTime(15)} style={{ padding: '8px 12px', fontSize: '12px', background: '#2a2a4e', border: '1px solid #444', borderRadius: '8px', color: '#fff', cursor: 'pointer' }}>+15s</button>
                        <span style={{ fontSize: '12px', color: '#666', minWidth: '40px', textAlign: 'right' }}>{formatTime(audioDuration)}</span>
                      </div>
                    </div>
                  )}

                  {ttsError && <div style={{ fontSize: '12px', color: '#f97316', marginBottom: '12px', padding: '8px 12px', background: '#4a2a1a', borderRadius: '6px' }}>‚ö†Ô∏è {ttsError}</div>}

                  <button onClick={() => setShowTranscript(!showTranscript)} style={{ background: 'transparent', border: 'none', color: '#888', fontSize: '14px', cursor: 'pointer', padding: '8px 0', display: 'flex', alignItems: 'center', gap: '6px' }}>
                    <span style={{ transform: showTranscript ? 'rotate(90deg)' : 'rotate(0deg)', transition: 'transform 0.2s', display: 'inline-block' }}>‚ñ∂</span>
                    {showTranscript ? 'Hide transcript' : 'Show full transcript'}
                  </button>
                  {showTranscript && <div style={{ color: '#ccc', lineHeight: '1.7', whiteSpace: 'pre-wrap', marginTop: '12px', padding: '16px', background: '#0f0f1a', borderRadius: '8px', border: '1px solid #333' }}>{stripAudioTags(roast)}</div>}
                </div>

                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))', gap: '16px', marginBottom: '24px' }}>
                  <ReportCard title="Buzzword Count" score={results.buzzwords.total} thresholds={{ a: 3, b: 8, c: 15, d: 25 }} details={Object.entries(results.buzzwords.matches).sort((a, b) => b[1] - a[1])} icon="üì¢" />
                  <ReportCard title="Vague Claims" score={results.vagueClaims.total} thresholds={{ a: 1, b: 3, c: 6, d: 10 }} details={Object.entries(results.vagueClaims.matches).sort((a, b) => b[1] - a[1])} icon="üå´Ô∏è" />
                  <ReportCard title="CTA Desperation" score={results.ctas.total} thresholds={{ a: 2, b: 5, c: 10, d: 15 }} details={Object.entries(results.ctas.matches).sort((a, b) => b[1] - a[1])} icon="üö®" />
                  <ReportCard title="Exclamation Abuse!" score={results.exclamationCount} thresholds={{ a: 2, b: 5, c: 10, d: 20 }} icon="‚ùó" />
                </div>

                <div style={{ background: '#1a1a2e', borderRadius: '12px', padding: '20px', display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', gap: '16px' }}>
                  <div style={{ textAlign: 'center' }}><div style={{ color: '#888', fontSize: '12px', marginBottom: '4px' }}>Word Count</div><div style={{ fontSize: '24px', fontWeight: 'bold' }}>{results.wordCount}</div></div>
                  <div style={{ textAlign: 'center' }}><div style={{ color: '#888', fontSize: '12px', marginBottom: '4px' }}>Avg Word Length</div><div style={{ fontSize: '24px', fontWeight: 'bold' }}>{results.avgWordLength}</div></div>
                  <div style={{ textAlign: 'center' }}><div style={{ color: '#888', fontSize: '12px', marginBottom: '4px' }}>We:You Ratio</div><div style={{ fontSize: '24px', fontWeight: 'bold', color: parseFloat(results.weYouRatio) > 1 ? '#ff6b6b' : '#22c55e' }}>{results.weYouRatio}</div></div>
                  <div style={{ textAlign: 'center' }}><div style={{ color: '#888', fontSize: '12px', marginBottom: '4px' }}>Avg Sentence</div><div style={{ fontSize: '24px', fontWeight: 'bold' }}>{results.avgSentenceLength}</div></div>
                </div>
              </div>
            )}

            <div style={{ textAlign: 'center', marginTop: '48px', color: '#444', fontSize: '14px' }}>
              <p>Built with cynicism and caffeine ‚òï</p>
              <p style={{ fontSize: '12px', marginTop: '8px' }}>No websites were permanently harmed in this roasting</p>
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<WebsiteRoaster />);
  </script>
</body>
</html>
